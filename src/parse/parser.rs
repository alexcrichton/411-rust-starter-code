// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]
use super::ast::*;
use super::parse_utils::{mark, str_to_ident, hex_to_num, int_to_num,
                         vec_to_expr};
use self::RuleResult::{Matched, Failed};
fn escape_default(s: &str) -> String {
    s.chars().flat_map(|c| c.escape_default()).collect()
}
fn char_range_at(s: &str, pos: usize) -> (char, usize) {
    let c = &s[pos..].chars().next().unwrap();
    let next_pos = pos + c.len_utf8();
    (*c, next_pos)
}
#[derive(Clone)]
enum RuleResult<T> { Matched(usize, T), Failed, }
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub expected: ::std::collections::HashSet<&'static str>,
}
pub type ParseResult<T> = Result<T, ParseError>;
impl ::std::fmt::Display for ParseError {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter)
     -> ::std::result::Result<(), ::std::fmt::Error> {
        try!(write ! (
             fmt , "error at {}:{}: expected " , self . line , self . column
             ));
        if self.expected.len() == 0 {
            try!(write ! ( fmt , "EOF" ));
        } else if self.expected.len() == 1 {
            try!(write ! (
                 fmt , "`{}`" , escape_default (
                 self . expected . iter (  ) . next (  ) . unwrap (  ) ) ));
        } else {
            let mut iter = self.expected.iter();
            try!(write ! (
                 fmt , "one of `{}`" , escape_default (
                 iter . next (  ) . unwrap (  ) ) ));
            for elem in iter {
                try!(write ! ( fmt , ", `{}`" , escape_default ( elem ) ));
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for ParseError {
    fn description(&self) -> &str { "parse error" }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: usize, m: &'static str)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           &input.as_bytes()[pos..pos + l] == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn slice_eq_case_insensitive(input: &str, state: &mut ParseState, pos: usize,
                             m: &'static str) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let mut used = 0usize;
    let mut input_iter = input[pos..].chars().flat_map(|x| x.to_uppercase());
    for m_char_upper in m.chars().flat_map(|x| x.to_uppercase()) {
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.next();
        if input_char_result.is_none() ||
               input_char_result.unwrap() != m_char_upper {
            return state.mark_failure(pos, m);
        }
    }
    Matched(pos + used, ())
}
fn any_char(input: &str, state: &mut ParseState, pos: usize)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        let (_, next) = char_range_at(input, pos);
        Matched(next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: usize) -> (usize, usize) {
    let mut remaining = pos;
    let mut lineno: usize = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length { return (lineno, remaining + 1); }
        remaining -= line_length;
        lineno += 1;
    }
    return (lineno, remaining + 1);
}
struct ParseState<'input> {
    max_err_pos: usize,
    expected: ::std::collections::HashSet<&'static str>,
    _phantom: ::std::marker::PhantomData<&'input ()>,
}
impl <'input> ParseState<'input> {
    fn new() -> ParseState<'input> {
        ParseState{max_err_pos: 0,
                   expected: ::std::collections::HashSet::new(),
                   _phantom: ::std::marker::PhantomData,}
    }
    fn mark_failure(&mut self, pos: usize, expected: &'static str)
     -> RuleResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos { self.expected.insert(expected); }
        Failed
    }
}
fn parse_singleline<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "//");
        match seq_res {
            Matched(pos, _) => {
                {
                    let mut repeat_pos = pos;
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let seq_res =
                                    {
                                        let assert_res =
                                            slice_eq(input, state, pos, "\n");
                                        match assert_res {
                                            Failed => Matched(pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        any_char(input, state, pos)
                                    }
                                    Failed => Failed,
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => { repeat_pos = newpos; }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, ())
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_multiline<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "/*");
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    {
                                        let choice_res =
                                            parse_multiline(input, state,
                                                            pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let seq_res =
                                                    {
                                                        let assert_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     "*/");
                                                        match assert_res {
                                                            Failed =>
                                                            Matched(pos, ()),
                                                            Matched(..) =>
                                                            Failed,
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        any_char(input, state,
                                                                 pos)
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            slice_eq(input, state, pos, "*/")
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_comment<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<()> {
    {
        let choice_res = parse_singleline(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_multiline(input, state, pos),
        }
    }
}
fn parse_whitespace<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            ' ' | '\t' | '\n' | '\r' | '\u{c}' | '\u{b}' => Matched(next, ()),
            _ => state.mark_failure(pos, "[ \t\n\r\u{c}\u{b}]"),
        }
    } else { state.mark_failure(pos, "[ \t\n\r\u{c}\u{b}]") }
}
fn parse__<'input>(input: &'input str, state: &mut ParseState<'input>,
                   pos: usize) -> RuleResult<()> {
    {
        let mut repeat_pos = pos;
        loop  {
            let pos = repeat_pos;
            let step_res =
                {
                    let choice_res = parse_whitespace(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => parse_comment(input, state, pos),
                    }
                };
            match step_res {
                Matched(newpos, value) => { repeat_pos = newpos; }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, ())
    }
}
fn parse_MAIN<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "main");
        match seq_res {
            Matched(pos, _) => { parse__(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_TYPE<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "int");
        match seq_res {
            Matched(pos, _) => {
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let choice_res =
                                    parse_whitespace(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    parse_comment(input, state, pos),
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1usize {
                        Matched(repeat_pos, ())
                    } else { Failed }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_ident<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Ident> {
    {
        let start_pos = pos;
        {
            let seq_res =
                if input.len() > pos {
                    let (ch, next) = char_range_at(input, pos);
                    match ch {
                        'a' ...'z' | 'A' ...'Z' | '_' => Matched(next, ()),
                        _ => state.mark_failure(pos, "[a-zA-Z_]"),
                    }
                } else { state.mark_failure(pos, "[a-zA-Z_]") };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        if input.len() > pos {
                                            let (ch, next) =
                                                char_range_at(input, pos);
                                            match ch {
                                                'a' ...'z' | 'A' ...'Z' | '0'
                                                ...'9' | '_' =>
                                                Matched(next, ()),
                                                _ =>
                                                state.mark_failure(pos,
                                                                   "[a-zA-Z0-9_]"),
                                            }
                                        } else {
                                            state.mark_failure(pos,
                                                               "[a-zA-Z0-9_]")
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, ())
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { str_to_ident(match_str) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_IDENT<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Ident> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_ident(input, state, pos);
            match seq_res {
                Matched(pos, i) => {
                    {
                        let seq_res = parse__(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { i })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_hex<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<u32> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            if input.len() > pos {
                                let (ch, next) = char_range_at(input, pos);
                                match ch {
                                    '0' ...'9' | 'a' ...'f' | 'A' ...'F' =>
                                    Matched(next, ()),
                                    _ =>
                                    state.mark_failure(pos, "[0-9a-fA-F]"),
                                }
                            } else { state.mark_failure(pos, "[0-9a-fA-F]") };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1usize {
                        Matched(repeat_pos, ())
                    } else { Failed }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos,
                                { hex_to_num(match_str, start_pos, pos) })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_const<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<u32> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "0");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    if input.len() > pos {
                                        let (ch, next) =
                                            char_range_at(input, pos);
                                        match ch {
                                            'x' | 'X' => Matched(next, ()),
                                            _ =>
                                            state.mark_failure(pos, "[xX]"),
                                        }
                                    } else {
                                        state.mark_failure(pos, "[xX]")
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_hex(input, state, pos);
                                            match seq_res {
                                                Matched(pos, h) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos, { h })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res =
                                if input.len() > pos {
                                    let (ch, next) =
                                        char_range_at(input, pos);
                                    match ch {
                                        '1' ...'9' => Matched(next, ()),
                                        _ => state.mark_failure(pos, "[1-9]"),
                                    }
                                } else { state.mark_failure(pos, "[1-9]") };
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            {
                                                let mut repeat_pos = pos;
                                                loop  {
                                                    let pos = repeat_pos;
                                                    let step_res =
                                                        if input.len() > pos {
                                                            let (ch, next) =
                                                                char_range_at(input,
                                                                              pos);
                                                            match ch {
                                                                '0' ...'9' =>
                                                                Matched(next,
                                                                        ()),
                                                                _ =>
                                                                state.mark_failure(pos,
                                                                                   "[0-9]"),
                                                            }
                                                        } else {
                                                            state.mark_failure(pos,
                                                                               "[0-9]")
                                                        };
                                                    match step_res {
                                                        Matched(newpos, value)
                                                        => {
                                                            repeat_pos =
                                                                newpos;
                                                        }
                                                        Failed => { break ; }
                                                    }
                                                }
                                                Matched(repeat_pos, ())
                                            };
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let match_str =
                                                        &input[start_pos..pos];
                                                    Matched(pos,
                                                            {
                                                                int_to_num(match_str,
                                                                           start_pos,
                                                                           pos)
                                                            })
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let start_pos = pos;
                        {
                            let seq_res = slice_eq(input, state, pos, "0");
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let match_str =
                                            &input[start_pos..pos];
                                        Matched(pos, { 0u32 })
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_CONST<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<u32> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_const(input, state, pos);
            match seq_res {
                Matched(pos, c) => {
                    {
                        let seq_res = parse__(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { c })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_ASNOP<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Operator> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "-=");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res = parse__(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos, { Operator::Minus })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = slice_eq(input, state, pos, "+=");
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            parse__(input, state, pos);
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let match_str =
                                                        &input[start_pos..pos];
                                                    Matched(pos,
                                                            {
                                                                Operator::Plus
                                                            })
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "*=");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse__(input, state,
                                                            pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    {
                                                                        Operator::Times
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         "/=");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            parse__(input,
                                                                    state,
                                                                    pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let match_str =
                                                                        &input[start_pos..pos];
                                                                    Matched(pos,
                                                                            {
                                                                                Operator::DividedBy
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                slice_eq(input, state, pos,
                                                         "%=");
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            parse__(input,
                                                                    state,
                                                                    pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let match_str =
                                                                        &input[start_pos..pos];
                                                                    Matched(pos,
                                                                            {
                                                                                Operator::Modulo
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_PLUS<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<Operator> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "+");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse__(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { Operator::Plus })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_MINUS<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Operator> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "-");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let assert_res =
                                    slice_eq(input, state, pos, "-");
                                match assert_res {
                                    Failed => Matched(pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res = parse__(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        { Operator::Minus })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_TIMES<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Operator> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "*");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse__(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { Operator::Times })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_DIV<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<Operator> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "/");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse__(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { Operator::DividedBy })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_MOD<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<Operator> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "%");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse__(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { Operator::Modulo })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_LPAREN<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "(");
        match seq_res {
            Matched(pos, _) => { parse__(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_RPAREN<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ")");
        match seq_res {
            Matched(pos, _) => { parse__(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_LBRACE<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "{");
        match seq_res {
            Matched(pos, _) => { parse__(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_RBRACE<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "}");
        match seq_res {
            Matched(pos, _) => { parse__(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_RETURN<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "return");
        match seq_res {
            Matched(pos, _) => { parse__(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_SEMICOLON<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ";");
        match seq_res {
            Matched(pos, _) => { parse__(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_EQUALS<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "=");
        match seq_res {
            Matched(pos, _) => { parse__(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_DECREMENT<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<()> {
    slice_eq(input, state, pos, "--")
}
fn parse_program<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Vec<Statement>> {
    {
        let start_pos = pos;
        {
            let seq_res = parse__(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_TYPE(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_MAIN(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_LPAREN(input, state,
                                                                 pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_RPAREN(input,
                                                                             state,
                                                                             pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_LBRACE(input,
                                                                                         state,
                                                                                         pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        {
                                                                                            let mut repeat_pos =
                                                                                                pos;
                                                                                            let mut repeat_value =
                                                                                                vec!();
                                                                                            loop 
                                                                                                 {
                                                                                                let pos =
                                                                                                    repeat_pos;
                                                                                                let step_res =
                                                                                                    parse_stmt(input,
                                                                                                               state,
                                                                                                               pos);
                                                                                                match step_res
                                                                                                    {
                                                                                                    Matched(newpos,
                                                                                                            value)
                                                                                                    =>
                                                                                                    {
                                                                                                        repeat_pos
                                                                                                            =
                                                                                                            newpos;
                                                                                                        repeat_value.push(value);
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    {
                                                                                                        break
                                                                                                            ;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            Matched(repeat_pos,
                                                                                                    repeat_value)
                                                                                        };
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                prog)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse_RBRACE(input,
                                                                                                                 state,
                                                                                                                 pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let match_str =
                                                                                                                &input[start_pos..pos];
                                                                                                            Matched(pos,
                                                                                                                    {
                                                                                                                        prog
                                                                                                                    })
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_stmt<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<Statement> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_RETURN(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res = parse_exp(input, state, pos);
                                match seq_res {
                                    Matched(pos, e) => {
                                        {
                                            let seq_res =
                                                parse_SEMICOLON(input, state,
                                                                pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    mark(Statement_::Return(e),
                                                                         start_pos,
                                                                         pos)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_simp(input, state, pos);
                            match seq_res {
                                Matched(pos, s) => {
                                    {
                                        let seq_res =
                                            parse_SEMICOLON(input, state,
                                                            pos);
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let match_str =
                                                        &input[start_pos..pos];
                                                    Matched(pos, { s })
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let start_pos = pos;
                        {
                            let seq_res = parse_decl(input, state, pos);
                            match seq_res {
                                Matched(pos, d) => {
                                    {
                                        let seq_res =
                                            parse_SEMICOLON(input, state,
                                                            pos);
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let match_str =
                                                        &input[start_pos..pos];
                                                    Matched(pos, { d })
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_decl<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<Statement> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_TYPE(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res = parse_IDENT(input, state, pos);
                                match seq_res {
                                    Matched(pos, i) => {
                                        {
                                            let seq_res =
                                                parse_EQUALS(input, state,
                                                             pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            parse_exp(input,
                                                                      state,
                                                                      pos);
                                                        match seq_res {
                                                            Matched(pos, e) =>
                                                            {
                                                                {
                                                                    let match_str =
                                                                        &input[start_pos..pos];
                                                                    Matched(pos,
                                                                            {
                                                                                mark(Statement_::DeclAssign(i,
                                                                                                            e),
                                                                                     start_pos,
                                                                                     pos)
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_TYPE(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res = parse_IDENT(input, state, pos);
                                match seq_res {
                                    Matched(pos, i) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos,
                                                    {
                                                        mark(Statement_::Decl(i),
                                                             start_pos, pos)
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_simp<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<Statement> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_lvalue(input, state, pos);
                    match seq_res {
                        Matched(pos, i) => {
                            {
                                let seq_res = parse_EQUALS(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_exp(input, state, pos);
                                            match seq_res {
                                                Matched(pos, e) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    mark(Statement_::Assign(i,
                                                                                            e),
                                                                         start_pos,
                                                                         pos)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_lvalue(input, state, pos);
                    match seq_res {
                        Matched(pos, i) => {
                            {
                                let seq_res = parse_ASNOP(input, state, pos);
                                match seq_res {
                                    Matched(pos, op) => {
                                        {
                                            let seq_res =
                                                parse_exp(input, state, pos);
                                            match seq_res {
                                                Matched(pos, e) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    mark(Statement_::Assign(i,
                                                                                            mark(Expression_::Binary(op,
                                                                                                                     Box::new(mark(Expression_::Variable(i),
                                                                                                                                   start_pos,
                                                                                                                                   pos)),
                                                                                                                     Box::new(e)),
                                                                                                 start_pos,
                                                                                                 pos)),
                                                                         start_pos,
                                                                         pos)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_lvalue<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<Ident> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_LPAREN(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res = parse_lvalue(input, state, pos);
                                match seq_res {
                                    Matched(pos, i) => {
                                        {
                                            let seq_res =
                                                parse_RPAREN(input, state,
                                                             pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos, { i })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_IDENT(input, state, pos);
                    match seq_res {
                        Matched(pos, i) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { i })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_exp<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<Expression> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_factor(input, state, pos);
            match seq_res {
                Matched(pos, e) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_exp_tail(input, state, pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, vec) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                if vec.is_empty() {
                                                    e
                                                } else {
                                                    vec_to_expr(e, vec,
                                                                start_pos,
                                                                pos)
                                                }
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_exp_tail<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<(Operator, Expression)> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res = parse_PLUS(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => parse_MINUS(input, state, pos),
                    }
                };
            match seq_res {
                Matched(pos, op) => {
                    {
                        let seq_res = parse_factor(input, state, pos);
                        match seq_res {
                            Matched(pos, e) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { (op, e) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_factor<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<Expression> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_primary(input, state, pos);
            match seq_res {
                Matched(pos, e) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_factor_tail(input, state, pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, vec) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                if vec.is_empty() {
                                                    e
                                                } else {
                                                    vec_to_expr(e, vec,
                                                                start_pos,
                                                                pos)
                                                }
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_factor_tail<'input>(input: &'input str,
                             state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<(Operator, Expression)> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res = parse_TIMES(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res = parse_DIV(input, state, pos);
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => parse_MOD(input, state, pos),
                            }
                        }
                    }
                };
            match seq_res {
                Matched(pos, op) => {
                    {
                        let seq_res = parse_primary(input, state, pos);
                        match seq_res {
                            Matched(pos, e) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { (op, e) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_primary<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Expression> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_LPAREN(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res = parse_exp(input, state, pos);
                                match seq_res {
                                    Matched(pos, e) => {
                                        {
                                            let seq_res =
                                                parse_RPAREN(input, state,
                                                             pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos, { e })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_DECREMENT(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            parse_primary(input, state, pos);
                                        match seq_res {
                                            Matched(pos, e) => {
                                                {
                                                    let match_str =
                                                        &input[start_pos..pos];
                                                    Matched(pos,
                                                            {
                                                                mark(Expression_::Unary(Operator::Decrement,
                                                                                        Box::new(e)),
                                                                     start_pos,
                                                                     pos)
                                                            })
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_MINUS(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_primary(input,
                                                                  state, pos);
                                                match seq_res {
                                                    Matched(pos, e) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    {
                                                                        mark(Expression_::Unary(Operator::Negative,
                                                                                                Box::new(e)),
                                                                             start_pos,
                                                                             pos)
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_CONST(input, state,
                                                            pos);
                                            match seq_res {
                                                Matched(pos, c) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    mark(Expression_::Constant(c),
                                                                         start_pos,
                                                                         pos)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_IDENT(input, state,
                                                            pos);
                                            match seq_res {
                                                Matched(pos, i) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    mark(Expression_::Variable(i),
                                                                         start_pos,
                                                                         pos)
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
pub fn program<'input>(input: &'input str) -> ParseResult<Vec<Statement>> {
    let mut state = ParseState::new();
    match parse_program(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
